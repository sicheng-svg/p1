没问题！这是一个非常明智的决定。先有顶层设计，等“弹药”（API 中转站）到位后再按图索骥进行开发，可以少走很多弯路。

我为你将刚才讨论的**“主从多智能体（Master-Worker）与通用助理混合架构”**整理成了一份标准的架构设计 Markdown 文档。你可以直接复制保存到你的本地笔记中。

---

# 🤖 全自动多智能体开发与助理工作流架构设计

**核心技术栈：** 飞书 (UI/交互) + OpenClaw (网关/调度) + Gemini (大脑/架构师) + Claude Code (执行器)
**运行环境：** Windows 宿主机 + WSL (Ubuntu) 底层控制

## 一、 系统角色定义

整个系统采用 **“智能网关 + 主从 Agent”** 的架构，各组件职责严格解耦：

* **📱 飞书 (前端监控大屏)：** 唯一的交互入口。负责接收用户的自然语言指令，并以消息卡片或 Thread（话题）的形式，实时展示 AI 的思考过程和底层代码执行进度。
* **⚙️ OpenClaw (中央编排引擎)：** 系统的“大管家”。负责维持飞书长连接、调用大模型 API、维持会话状态、调度本地工具（Tool Calling）以及管理本地子进程。
* **🧠 Gemini (架构师 / 全能助理)：** 系统的“Master 大脑”。负责意图识别、复杂需求的多轮自我反思（Self-Reflection）、撰写标准需求文档（PRD），以及处理非代码类的日常/学习任务。
* **💻 Claude Code (本地执行专家)：** 系统的“Worker 码农”。专门负责在 WSL 终端中读取 PRD 文档，静默执行文件读写、C/C++ 编码、CMake 构建、错误排查等底层工作。

## 二、 核心工作流 (Workflow)

当用户在飞书发送一条消息后，OpenClaw 将触发以下状态流转：

### 1. 意图路由网关 (Intent Routing)

OpenClaw 接收消息并请求 Gemini，Gemini 首判断任务类型：

* **分支 A：日常/学习任务 (无代码需求)** -> 进入**通用助理流**
* **分支 B：开发/工程任务 (需修改系统)** -> 进入**研发架构流**

### 2. 分支 A：通用助理流 (General Assistant)

* **场景：** 写大作业报告、制作 PPT 大纲、社交媒体文案等。
* **动作：** Gemini 直接生成最终结果。
* **输出：** OpenClaw 将结果直接格式化并推送回飞书，流程结束。不唤醒任何底层代码工具。

### 3. 分支 B：研发架构流 (Master-Worker Dev Flow)

此分支包含三个阶段的精密协同：

* **阶段一：架构师思考与设计 (Gemini 阶段)**
* Gemini 根据系统提示词，针对需求进行边界条件和技术栈（如 CMake、Protobuf）的自我审查。
* **可视化：** 飞书收到 `[状态更新] 🧠 架构师正在梳理需求与边界...`
* **落地：** Gemini 在 WSL 工作区生成标准化的需求文档，例如 `prd_ready.md`。


* **阶段二：任务交接与进程唤醒 (OpenClaw 阶段)**
* OpenClaw 监听到 `prd_ready.md` 生成（或通过 Gemini 调用特定 Tool 触发）。
* OpenClaw 在后台启动 `claude` CLI 子进程，并将文档路径作为 `stdin` 传入。


* **阶段三：本地执行与全程监控 (Claude Code 阶段)**
* Claude Code 读取文档，开始在本地执行创建文件、敲代码、编译、Debug 的循环。
* **可视化 (核心)：** OpenClaw 实时监听 Claude Code 的 `stdout/stderr` 标准输出流。提取关键执行动作（如“执行 CMake”、“编译报错重试中”），以子消息 (Thread) 的形式，流式推送到飞书的原始任务卡片下。
* 执行完毕，汇总结果至飞书。



## 三、 关键技术落地节点 (Implementation Nodes)

在实施阶段，需要重点攻克以下三个技术节点：

1. **大模型接入与提示词工程：**
* 配置 Gemini API (寻找合适的 API 中转/代理)。
* 编写 System Prompt，赋予其“意图识别”和“架构师自我反思”的强制输出格式要求。


2. **Tool Calling 与进程管理：**
* 在 OpenClaw 中开发一个自定义工具（如 `start_coding_worker`）。
* 使用 Node.js / Python 的 `spawn` 或 `exec` 模块管理 Claude Code 子进程的生命周期。


3. **流式日志解析与飞书 API 交互：**
* 过滤终端输出中的 ANSI 颜色字符和冗余进度条。
* 调用飞书的“回复消息”接口，将关键日志追加到 Thread 中，实现“可视化监控大屏”。



---

这份文档为你未来的开发定下了清晰的基调。等你找到了稳定的 Gemini API 中转站，我们随时可以从“意图路由器”的第一行代码开始写起！如果在这期间你对架构设计还有任何新的灵感，或者想先研究一下哪部分的代码实现，随时叫我。